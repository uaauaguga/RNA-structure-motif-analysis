#!/usr/bin/env python
import argparse 
from collections import defaultdict
from tqdm import tqdm
import HTSeq

def parse_paf_record(line):
    fields = line.strip().split("\t")
    #query_name, target_name = fields[0], fields[5]
    query_name = fields[0]
    #query_length, target_length = int(fields[1]), int(fields[6])
    aligned_length = int(fields[9])
    query_start, query_end = int(fields[2]), int(fields[3])
    divergence = None
    for field in fields[12:]:
        if field.startswith("dv"):
            divergence = float(field.split(":")[-1])
            break
    assert divergence is not None, f"{line.strip()} does not contain a dv tag ..."
    #return query_name, query_start, query_end, divergence
    return query_name, query_start, query_end, divergence
    #return query_name, target_name, query_length, target_length, aligned_length, divergence


def main():
    parser = argparse.ArgumentParser(description='summarize coverage of contig reassembly')
    parser.add_argument('--paf',type=str,required=True,help="paf file generated by mapping concatenated single run assembly to reassembled sequences")
    parser.add_argument('--fai',type=str,required=True,help="fasta index of concatenated single run assembly")
    args = parser.parse_args() 
    max_div = 0.01
    ga = HTSeq.GenomicArray("auto", stranded=False)
    print("Load pairwise search results ...")
    with open(args.paf) as f:
        for line in tqdm(f):
            line = line.strip()
            query_name, query_start, query_end, divergence = parse_paf_record(line)
            if divergence > max_div:
                continue
            iv = HTSeq.GenomicInterval(query_name, query_start, query_end, strand = ".") 
            ga[iv] += 1
    coverage = defaultdict(int)
    for iv, count in tqdm(ga.steps()):
        if count == 0:
            continue
        coverage[iv.chrom] += (iv.end - iv.start)
    print("Annotate contig coverage ...")
    covered_by_length = defaultdict(list)
    total_by_length = defaultdict(list)
    with open(args.fai) as f:
        for line in tqdm(f):
            query_name, length = line.strip().split("\t")[:2]
            length = int(length)
            L = int(length/1000)
            covered_by_length[L].append(coverage[query_name])
            total_by_length[L].append(length)
    N_total = 0
    N_covered = 0
    for L in sorted(list(total_by_length.keys())):
        n_covered_base = sum(covered_by_length[L])
        n_total_base = sum(total_by_length[L])
        N_covered += n_covered_base
        N_total += n_total_base
        n_covered_contig = sum([x>0 for x in covered_by_length[L]])
        n_total_contig = len(covered_by_length[L])
        print(L,n_covered_base,n_total_base,n_covered_base/n_total_base,n_covered_contig,n_total_contig,n_covered_contig/n_total_contig,sep="\t")
    print(N_covered,N_total,N_covered/N_total,sep="\t")
     


if __name__ == "__main__":
    main()
